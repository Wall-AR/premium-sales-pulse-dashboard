import { supabase } from '@/integrations/supabase/client';

export interface HistoryLogRecord {
  id: string; // UUID, primary key
  timestamp: string; // ISO string, auto-generated by DB (default now())
  user_id: string; // User's UUID
  user_email: string; // User's email (for display, denormalized)
  action_type: string; // e.g., 'SELLER_CREATED', 'SALE_UPDATED'
  record_type: string; // e.g., 'seller', 'sale'
  record_id: string; // ID of the affected seller or sale
  details: string; // Descriptive string of the action, or JSON string
}

// Data needed to create a new log entry. DB handles 'id' and 'timestamp'.
export type NewHistoryLogEntryData = Omit<HistoryLogRecord, 'id' | 'timestamp'>;

/**
 * Adds a new entry to the activity_log table.
 * @param logData The data for the new log entry.
 * @returns An object containing an error if one occurred.
 */
export const addHistoryLogEntry = async (
  logData: NewHistoryLogEntryData
): Promise<{ error: any }> => {
  
  const dataToInsert = {
    ...logData,
    // timestamp is set by default in the database using now()
  };

  const { error } = await supabase
    .from('activity_log') // Name of the Supabase table for history logs
    .insert(dataToInsert);

  if (error) {
    console.error('Error adding history log entry:', error);
    // It's important not to let logging failures block primary operations.
    // So, we log the error but don't necessarily throw it to stop the parent process.
    // The calling function can decide how critical logging errors are.
  }
  
  return { error };
};
